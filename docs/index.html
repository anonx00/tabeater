<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y6MEHQB9CZ"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-Y6MEHQB9CZ');
    </script>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="yhRyISPn3LazheWF4hgVgO8LeWerv_vxFuUdZ24GRlE" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Primary Meta Tags - Optimized for Search -->
    <title>TabEater - Best AI Tab Manager for Chrome | Organize 100+ Tabs Instantly</title>
    <meta name="title" content="TabEater - Best AI Tab Manager for Chrome | Organize 100+ Tabs Instantly">
    <meta name="description" content="Chrome extension to organize browser tabs with AI. 7-day free trial. Auto-close duplicate tabs, smart tab grouping, and chat with AI about your tabs. Works with ChatGPT, Gemini, Claude. Trusted by 1000+ users.">
    <meta name="keywords" content="tab manager chrome, chrome tab organizer, best tab manager extension, organize browser tabs, close duplicate tabs chrome, tab groups extension, AI tab manager, too many tabs chrome, chrome tab management, browser tab organizer, auto close tabs, tab declutter extension, one tab alternative, reduce chrome memory, tab overload solution">
    <meta name="author" content="TabEater">
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta name="googlebot" content="index, follow">
    <link rel="canonical" href="https://anonx00.github.io/tabeater/">

    <!-- Preload Critical Resources -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" as="style">
    <link rel="dns-prefetch" href="https://chromewebstore.google.com">
    <link rel="dns-prefetch" href="https://unpkg.com">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://anonx00.github.io/tabeater/">
    <meta property="og:title" content="TabEater - Best AI Tab Manager for Chrome | 7-Day Free Trial">
    <meta property="og:description" content="Finally organize your 100+ browser tabs. AI-powered Chrome extension that auto-groups tabs, closes duplicates, and lets you chat with AI about your open pages.">
    <meta property="og:image" content="https://anonx00.github.io/tabeater/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="TabEater Chrome Extension - AI Tab Manager">
    <meta property="og:site_name" content="TabEater">
    <meta property="og:locale" content="en_US">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://anonx00.github.io/tabeater/">
    <meta name="twitter:title" content="TabEater - Best AI Tab Manager for Chrome">
    <meta name="twitter:description" content="Finally organize your 100+ browser tabs with AI. 7-day free trial.">
    <meta name="twitter:image" content="https://anonx00.github.io/tabeater/og-image.png">
    <meta name="twitter:creator" content="@tabeater">

    <!-- Additional SEO -->
    <meta name="theme-color" content="#0a0a0a">
    <meta name="application-name" content="TabEater">
    <meta name="apple-mobile-web-app-title" content="TabEater">
    <meta name="format-detection" content="telephone=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <!-- JSON-LD Structured Data: SoftwareApplication -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "TabEater",
        "applicationCategory": "BrowserApplication",
        "applicationSubCategory": "Productivity",
        "operatingSystem": "Chrome",
        "description": "AI-powered Chrome extension to organize, group, and manage browser tabs. Features include duplicate detection, smart tab grouping, auto-pilot mode, and AI chat.",
        "url": "https://anonx00.github.io/tabeater/",
        "downloadUrl": "https://chromewebstore.google.com/detail/tabeater/khehjgmppbfpmibjcjeffbndjcnbogfj",
        "installUrl": "https://chromewebstore.google.com/detail/tabeater/khehjgmppbfpmibjcjeffbndjcnbogfj",
        "screenshot": "https://anonx00.github.io/tabeater/og-image.png",
        "softwareVersion": "1.0",
        "datePublished": "2024-01-01",
        "author": {
            "@type": "Organization",
            "name": "TabEater",
            "url": "https://anonx00.github.io/tabeater/"
        },
        "publisher": {
            "@type": "Organization",
            "name": "TabEater"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD",
            "availability": "https://schema.org/InStock"
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "5",
            "bestRating": "5",
            "worstRating": "1",
            "ratingCount": "10"
        },
        "featureList": [
            "AI-powered tab organization",
            "Duplicate tab detection and removal",
            "Smart tab grouping by domain and topic",
            "Auto-pilot mode for automatic organization",
            "Tab chat with AI insights",
            "Chrome side panel support",
            "Multiple AI providers (OpenAI, Gemini, Claude)",
            "Memory usage optimization",
            "One-click tab cleanup"
        ],
        "softwareRequirements": "Google Chrome 88+",
        "permissions": "tabs, storage"
    }
    </script>

    <!-- JSON-LD Structured Data: FAQ for Rich Snippets -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What is the best Chrome extension for managing too many tabs?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "TabEater is an AI-powered Chrome extension that helps you manage hundreds of tabs effortlessly. It automatically groups tabs by topic, detects and closes duplicates, and lets you chat with AI about your open pages. Unlike other tab managers, TabEater uses AI to intelligently organize your tabs based on content, not just domain."
                }
            },
            {
                "@type": "Question",
                "name": "How do I organize my Chrome tabs automatically?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Install TabEater from the Chrome Web Store and enable Auto-Pilot mode. TabEater will automatically organize new tabs in the background, group them by topic, and close duplicates. You can also click the extension icon to manually organize all tabs with one click."
                }
            },
            {
                "@type": "Question",
                "name": "Is TabEater free to use?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "TabEater offers a 7-day free trial with full access. After that, you can get lifetime PRO access for just $6 AUD (one-time payment). You bring your own API key from OpenAI, Google Gemini, or Anthropic Claude."
                }
            },
            {
                "@type": "Question",
                "name": "How do I close duplicate tabs in Chrome?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "With TabEater, click the extension icon and select 'Find Duplicates'. TabEater will instantly scan all your open tabs and identify exact duplicates. You can then close them with one click, freeing up memory and reducing browser clutter."
                }
            },
            {
                "@type": "Question",
                "name": "Does TabEater collect my browsing data?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "No, TabEater does not collect any browsing data. Your API keys and preferences are stored locally in your browser. AI requests go directly from your browser to your chosen provider (OpenAI, Gemini, or Claude). TabEater is also open source so you can audit the code yourself."
                }
            },
            {
                "@type": "Question",
                "name": "What AI providers does TabEater support?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "TabEater supports multiple AI providers: OpenAI (GPT-4, GPT-3.5), Google Gemini, and Anthropic Claude. You can choose your preferred provider in the settings and switch between them anytime."
                }
            }
        ]
    }
    </script>

    <!-- JSON-LD Structured Data: Organization -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Organization",
        "name": "TabEater",
        "url": "https://anonx00.github.io/tabeater/",
        "logo": "https://anonx00.github.io/tabeater/og-image.png",
        "sameAs": [
            "https://github.com/anonx00/tabeater",
            "https://chromewebstore.google.com/detail/tabeater/khehjgmppbfpmibjcjeffbndjcnbogfj"
        ]
    }
    </script>

    <!-- JSON-LD Structured Data: WebSite with SearchAction -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "TabEater",
        "url": "https://anonx00.github.io/tabeater/",
        "description": "AI-powered Chrome tab manager extension",
        "publisher": {
            "@type": "Organization",
            "name": "TabEater"
        }
    }
    </script>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' fill='%230a0a0a' rx='4'/%3E%3Cpath d='M4 8.5V26C4 27 5 28 6 28H26C27 28 28 27 28 26V11C28 10 27 9 26 9H16L13 5H6C5 5 4 6 4 7V8.5Z' fill='none' stroke='%2300FF88' stroke-width='2'/%3E%3Crect x='8' y='13' width='6' height='6' fill='%2300FF88'/%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&family=Orbitron:wght@400;500;600;700;800&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --accent: #00FFCC;
            --accent-dim: rgba(0, 255, 204, 0.12);
            --accent-glow: rgba(0, 255, 204, 0.6);
            --cyan: #00FFFF;
            --purple: #BF00FF;
            --magenta: #FF00AA;
            --orange: #FF6600;
            --gold: #FFD700;
            --red: #FF3366;
            --blue: #00BFFF;
            --bg-dark: #020206;
            --bg-card: rgba(0, 8, 20, 0.4);
            --bg-section: rgba(0, 8, 20, 0.5);
            --border: rgba(0, 255, 255, 0.15);
            --border-glow: rgba(0, 255, 204, 0.3);
            --text: #ffffff;
            --text-dim: #a0a0a0;
            --text-muted: #808080;
            --radius: 16px;
            --radius-sm: 12px;
            --radius-lg: 24px;
        }

        html { scroll-behavior: smooth; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(180deg,
                rgba(0, 5, 15, 0.95) 0%,
                rgba(0, 8, 20, 0.9) 30%,
                rgba(0, 5, 15, 0.85) 70%,
                rgba(0, 3, 10, 0.95) 100%);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* Canvas - First child of body, fixed background with interaction */
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 0;
            pointer-events: auto;
            cursor: grab;
            /* Fallback background while Three.js loads */
            background: radial-gradient(ellipse at center bottom, #001a33 0%, #000508 50%, #000 100%);
            /* Smooth fade-in for premium feel */
            opacity: 0;
            animation: canvasFadeIn 2.5s ease-out 0.3s forwards;
        }

        #bg-canvas:active {
            cursor: grabbing;
        }

        @keyframes canvasFadeIn {
            to { opacity: 1; }
        }

        /* CRT Scanline Overlay */
        .scanline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.03) 0px,
                rgba(0, 0, 0, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            opacity: 0.4;
        }

        .content {
            position: relative;
            z-index: 10;
        }

        /* Hero - TRON Style */
        .hero {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: center;
            padding: 2rem 4rem;
            text-align: left;
            position: relative;
        }

        .hero-content {
            background: linear-gradient(135deg, rgba(0, 10, 20, 0.85) 0%, rgba(0, 5, 15, 0.9) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 3rem;
            border-radius: 4px;
            border: 2px solid rgba(0, 255, 255, 0.4);
            border-left: 4px solid var(--accent);
            box-shadow:
                0 0 40px rgba(0, 255, 255, 0.2),
                0 0 80px rgba(0, 255, 136, 0.1),
                inset 0 0 30px rgba(0, 255, 255, 0.05);
            max-width: 560px;
            position: relative;
            overflow: hidden;
        }

        /* TRON scan line effect */
        .hero-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            animation: scanLine 3s ease-in-out infinite;
        }

        @keyframes scanLine {
            0% { top: 0; opacity: 1; }
            50% { top: 100%; opacity: 0.5; }
            100% { top: 0; opacity: 1; }
        }

        /* Corner accents */
        .hero-content::after {
            content: '';
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            border-top: 2px solid var(--accent);
            border-right: 2px solid var(--accent);
        }

        .logo-container {
            position: relative;
            margin-bottom: 1.2rem;
            opacity: 0;
            animation: typeIn 0.5s ease-out 0.2s forwards;
        }

        .logo {
            width: 60px;
            height: 60px;
            filter: drop-shadow(0 0 20px var(--accent-glow));
        }

        .logo-glow {
            display: none;
        }

        /* TRON-style typography */
        .headline {
            font-family: 'Orbitron', 'Courier New', monospace;
            font-size: clamp(1.8rem, 4vw, 2.8rem);
            font-weight: 700;
            letter-spacing: 0.05em;
            line-height: 1.2;
            margin-bottom: 1rem;
            color: #fff;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5), 0 0 40px rgba(0, 255, 136, 0.3);
            opacity: 0;
            animation: typeIn 0.8s ease-out 0.5s forwards;
        }

        .headline-accent {
            display: block;
            background: linear-gradient(90deg, var(--accent) 0%, var(--cyan) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            filter: drop-shadow(0 0 20px var(--accent));
            animation: typeIn 0.8s ease-out 0.8s forwards, glowPulse 2s ease-in-out infinite 1.5s;
            opacity: 0;
        }

        @keyframes typeIn {
            0% { opacity: 0; transform: translateX(-20px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        @keyframes glowPulse {
            0%, 100% { filter: drop-shadow(0 0 20px var(--accent)); }
            50% { filter: drop-shadow(0 0 40px var(--accent)) drop-shadow(0 0 60px var(--cyan)); }
        }

        .subheadline {
            font-family: 'Share Tech Mono', 'Courier New', monospace;
            font-size: clamp(0.8rem, 1.4vw, 0.95rem);
            color: rgba(0, 255, 255, 0.7);
            max-width: 420px;
            margin: 0 0 2rem;
            font-weight: 400;
            letter-spacing: 0.02em;
            line-height: 1.6;
            opacity: 0;
            animation: typeIn 0.6s ease-out 1.1s forwards;
        }

        .subheadline::before {
            content: '> ';
            color: var(--accent);
        }

        .cta-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: flex-start;
            opacity: 0;
            animation: typeIn 0.6s ease-out 1.4s forwards;
        }

        /* TRON-style buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.9rem 1.8rem;
            border-radius: 2px;
            font-family: 'Orbitron', 'Share Tech Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            text-decoration: none;
            transition: all 0.2s ease;
            cursor: pointer;
            border: none;
            position: relative;
            z-index: 20;
        }

        .btn-primary {
            background: var(--accent);
            color: #000;
            border: 2px solid var(--accent);
            box-shadow:
                0 0 20px rgba(0, 255, 136, 0.4),
                inset 0 0 20px rgba(255, 255, 255, 0.1);
        }

        .btn-primary:hover {
            background: transparent;
            color: var(--accent);
            box-shadow:
                0 0 30px rgba(0, 255, 136, 0.6),
                0 0 60px rgba(0, 255, 136, 0.3);
        }

        .btn-primary svg { width: 16px; height: 16px; }

        .btn-secondary {
            background: transparent;
            color: rgba(0, 255, 255, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.4);
        }

        .btn-secondary:hover {
            border-color: var(--cyan);
            color: var(--cyan);
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        /* Focus states for accessibility */
        .btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 3px;
        }

        .btn:active {
            transform: translateY(0) scale(0.98);
        }

        .scroll-indicator {
            position: absolute;
            bottom: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.4rem;
            color: var(--text-muted);
            font-size: 0.6rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            animation: bounce 2.5s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(10px); }
            60% { transform: translateY(5px); }
        }

        .scroll-indicator svg { width: 14px; height: 14px; opacity: 0.3; }

        /* Status indicator */
        .status-indicator {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 5, 15, 0.9);
            backdrop-filter: blur(20px);
            padding: 8px 14px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            z-index: 100;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--cyan);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--cyan);
            box-shadow: 0 0 15px var(--cyan), 0 0 30px var(--cyan);
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }

        /* Sections */
        .section-backdrop {
            background: rgba(0, 5, 12, 0.9);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border-top: 1px solid rgba(0, 255, 255, 0.2);
        }

        .features {
            padding: 5rem 2rem;
            border-top: 1px solid var(--border);
        }

        .section-header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .section-label {
            font-size: 0.6rem;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            color: var(--accent);
            margin-bottom: 0.6rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        .section-title {
            font-size: clamp(1.4rem, 3vw, 2rem);
            font-weight: 700;
            letter-spacing: -0.02em;
            color: var(--text);
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 1.25rem;
            max-width: 920px;
            margin: 0 auto;
        }

        .feature-card {
            padding: 1.75rem;
            background: rgba(0, 12, 28, 0.35);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 255, 0.1);
            border-radius: var(--radius);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
        }

        .feature-card:hover {
            border-color: rgba(0, 255, 204, 0.25);
            transform: translateY(-6px);
            box-shadow:
                0 24px 48px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(0, 255, 204, 0.1);
            background: rgba(0, 16, 36, 0.45);
        }

        .feature-icon {
            width: 44px;
            height: 44px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 204, 0.08);
            border: 1px solid rgba(0, 255, 204, 0.15);
            border-radius: var(--radius-sm);
            color: var(--accent);
        }

        .feature-icon svg { width: 20px; height: 20px; }

        .feature-card h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
            letter-spacing: -0.01em;
        }

        .feature-card p {
            font-size: 0.82rem;
            color: var(--text-dim);
            line-height: 1.6;
        }

        /* Privacy */
        .privacy {
            padding: 5rem 2rem;
            border-top: 1px solid var(--border);
        }

        .privacy-container {
            max-width: 680px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 2rem;
            align-items: center;
        }

        .shield-icon {
            width: 80px;
            height: 80px;
            color: var(--cyan);
            filter: drop-shadow(0 0 30px rgba(0, 255, 255, 0.4));
        }

        .privacy-content h2 {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .privacy-content > p {
            color: var(--text-dim);
            margin-bottom: 0.875rem;
            font-size: 0.85rem;
        }

        .privacy-list { list-style: none; }

        .privacy-list li {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.3rem 0;
            color: var(--text-dim);
            font-size: 0.78rem;
        }

        .privacy-list li svg {
            width: 13px;
            height: 13px;
            color: var(--accent);
            flex-shrink: 0;
        }

        /* Providers */
        .providers {
            padding: 2.5rem 2rem;
            border-top: 1px solid var(--border);
        }

        .providers-container {
            max-width: 680px;
            margin: 0 auto;
            text-align: center;
        }

        .providers-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            margin-bottom: 0.875rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            font-family: 'JetBrains Mono', monospace;
        }

        .providers-grid {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            flex-wrap: wrap;
        }

        .provider {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            color: var(--text-dim);
            font-weight: 500;
            font-size: 0.8rem;
            transition: all 0.3s;
        }

        .provider:hover { color: var(--text); }
        .provider svg { width: 18px; height: 18px; opacity: 0.5; }

        /* CTA */
        .cta-section {
            padding: 4rem 2rem;
            text-align: center;
            border-top: 1px solid var(--border);
        }

        .cta-section h2 {
            font-size: clamp(1.2rem, 2.5vw, 1.6rem);
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .cta-section p {
            color: var(--text-dim);
            margin-bottom: 1.25rem;
            max-width: 320px;
            margin-left: auto;
            margin-right: auto;
            font-size: 0.85rem;
        }

        /* How It Works */
        .how-it-works {
            padding: 5rem 2rem;
        }

        .steps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.5rem;
            max-width: 880px;
            margin: 0 auto;
        }

        .step-card {
            padding: 1.5rem;
            background: rgba(0, 15, 35, 0.4);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(0, 255, 255, 0.15);
            border-radius: 16px;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .step-card:hover {
            border-color: rgba(0, 255, 255, 0.4);
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 40px rgba(0, 255, 255, 0.15);
        }

        .step-number {
            width: 48px;
            height: 48px;
            margin: 0 auto 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--accent) 0%, var(--cyan) 100%);
            border-radius: 50%;
            font-size: 1.25rem;
            font-weight: 700;
            color: #000;
        }

        .step-card h3 {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .step-card p {
            font-size: 0.78rem;
            color: var(--text-dim);
            line-height: 1.5;
        }

        /* FAQ Section */
        .faq {
            padding: 5rem 2rem;
        }

        .faq-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .faq-item {
            background: rgba(0, 15, 35, 0.4);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(0, 255, 255, 0.15);
            border-radius: 12px;
            margin-bottom: 1rem;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .faq-item:hover {
            border-color: rgba(0, 255, 255, 0.3);
        }

        .faq-question {
            padding: 1.25rem 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text);
        }

        .faq-question:hover {
            color: var(--accent);
        }

        .faq-toggle {
            color: var(--accent);
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .faq-item.active .faq-toggle {
            transform: rotate(45deg);
        }

        .faq-answer {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .faq-item.active .faq-answer {
            max-height: 300px;
        }

        .faq-answer p {
            padding: 0 1.5rem 1.25rem;
            font-size: 0.82rem;
            color: var(--text-dim);
            line-height: 1.7;
        }

        /* Footer */
        .footer {
            padding: 1.25rem 2rem;
            text-align: center;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            background: rgba(0, 5, 12, 0.95);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .footer-links a {
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.7rem;
            transition: color 0.3s;
        }

        .footer-links a:hover { color: var(--accent); }
        .footer-copy { font-size: 0.6rem; color: var(--text-muted); }

        /* Responsive */
        @media (max-width: 768px) {
            .hero { padding: 1.5rem; align-items: center; text-align: center; }
            .hero-content { padding: 2rem; max-width: 340px; }
            .cta-group { justify-content: center; }
            .trust-badge { justify-content: center; }
            .privacy-container { grid-template-columns: 1fr; text-align: center; }
            .privacy-visual { order: -1; }
            .shield-icon { width: 60px; height: 60px; }
            .privacy-list { display: inline-block; text-align: left; }
            .cta-group { flex-direction: column; width: 100%; max-width: 240px; }
            .btn { width: 100%; justify-content: center; }
            .features-grid { grid-template-columns: 1fr; }
            .stats-badge { top: 10px; right: 10px; padding: 8px 12px; font-size: 0.65rem; }
            .status-indicator { display: none; }
        }

        /* Tablet breakpoint */
        @media (min-width: 769px) and (max-width: 1024px) {
            .hero-content { max-width: 480px; padding: 3rem; }
            .features-grid { grid-template-columns: repeat(2, 1fr); max-width: 700px; }
            .steps-grid { grid-template-columns: repeat(2, 1fr); max-width: 600px; }
            .faq-container { max-width: 700px; }
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* ========================================
           LIVE STATS BAR
           ======================================== */
        .stats-bar {
            padding: 2rem 1.5rem;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
            background: rgba(0, 8, 20, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .stats-container {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            gap: 3rem;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
            position: relative;
            padding: 0 1.5rem;
        }

        .stat-item:not(:last-child)::after {
            content: '';
            position: absolute;
            right: -1.5rem;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 40px;
            background: linear-gradient(180deg, transparent, var(--cyan), transparent);
            opacity: 0.3;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            background: linear-gradient(135deg, var(--cyan) 0%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.2;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.3rem;
        }

        .stat-value .live-dot {
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            animation: livePulse 2s ease-in-out infinite;
            box-shadow: 0 0 10px var(--accent);
        }

        @keyframes livePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .stat-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 0.3rem;
            font-family: 'JetBrains Mono', monospace;
        }

        @media (max-width: 768px) {
            .stats-container {
                gap: 1.5rem;
            }
            .stat-item {
                padding: 0 1rem;
            }
            .stat-item:not(:last-child)::after {
                display: none;
            }
            .stat-value {
                font-size: 1.4rem;
            }
        }

        /* ========================================
           UI/UX IMPROVEMENTS
           ======================================== */

        /* Scroll Progress Bar */
        .scroll-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: linear-gradient(90deg, var(--accent) 0%, var(--cyan) 50%, var(--purple) 100%);
            z-index: 1000;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px var(--accent), 0 0 20px var(--cyan);
        }

        /* Enhanced Primary Button */
        .btn-primary {
            background: linear-gradient(135deg, var(--accent) 0%, #00CC99 100%);
            color: #000;
            font-size: 1rem;
            padding: 1rem 2rem;
            box-shadow:
                0 4px 24px rgba(0, 255, 204, 0.4),
                0 0 40px rgba(0, 255, 204, 0.2),
                0 0 60px rgba(0, 255, 204, 0.1);
            animation: btnPulse 2s ease-in-out infinite;
        }

        @keyframes btnPulse {
            0%, 100% { box-shadow: 0 4px 24px rgba(0, 255, 204, 0.4), 0 0 40px rgba(0, 255, 204, 0.2); }
            50% { box-shadow: 0 4px 32px rgba(0, 255, 204, 0.6), 0 0 60px rgba(0, 255, 204, 0.3); }
        }

        .btn-primary:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow:
                0 8px 40px rgba(0, 255, 204, 0.6),
                0 0 80px rgba(0, 255, 204, 0.4);
        }

        .btn-primary:active {
            transform: translateY(-2px) scale(0.98);
        }

        /* Secondary button improvements */
        .btn-secondary {
            padding: 0.75rem 1.5rem;
            font-size: 0.85rem;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 255, 204, 0.15);
        }

        /* Trust Badge */
        .trust-badge {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 0.6rem;
            margin-top: 1.5rem;
            font-size: 0.7rem;
            color: rgba(0, 255, 255, 0.5);
            font-family: 'Share Tech Mono', monospace;
            letter-spacing: 0.05em;
            opacity: 0;
            animation: typeIn 0.5s ease-out 1.7s forwards;
        }

        .trust-badge svg {
            width: 14px;
            height: 14px;
            color: var(--accent);
        }

        .trust-badge span {
            opacity: 0.7;
        }

        /* Chrome Badge */
        .chrome-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: transparent;
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 6px 12px;
            border-radius: 2px;
            font-size: 0.65rem;
            color: rgba(0, 255, 255, 0.7);
            margin-top: 1rem;
            font-family: 'Share Tech Mono', monospace;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            opacity: 0;
            animation: typeIn 0.5s ease-out 2s forwards;
        }

        .chrome-badge svg {
            width: 12px;
            height: 12px;
        }

        /* Back to Top Button */
        .back-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 48px;
            height: 48px;
            background: rgba(0, 10, 25, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .back-to-top:hover {
            background: rgba(0, 255, 204, 0.15);
            border-color: var(--accent);
            transform: translateY(-4px);
            box-shadow: 0 4px 20px rgba(0, 255, 204, 0.3);
        }

        .back-to-top svg {
            width: 20px;
            height: 20px;
            color: var(--accent);
        }

        /* Improved FAQ Toggle */
        .faq-toggle {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 204, 0.1);
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .faq-toggle svg {
            width: 14px;
            height: 14px;
            color: var(--accent);
            transition: transform 0.3s ease;
        }

        .faq-item.active .faq-toggle {
            background: var(--accent);
            transform: none;
        }

        .faq-item.active .faq-toggle svg {
            color: #000;
            transform: rotate(180deg);
        }

        .faq-item.active {
            border-color: rgba(0, 255, 204, 0.4);
            background: rgba(0, 20, 40, 0.5);
        }

        /* Step Connectors */
        .steps-grid {
            position: relative;
        }

        .step-card {
            position: relative;
        }

        .step-connector {
            display: none;
        }

        @media (min-width: 769px) {
            .step-connector {
                display: block;
                position: absolute;
                top: 50%;
                right: -1.5rem;
                width: 1.5rem;
                height: 2px;
                background: linear-gradient(90deg, var(--accent) 0%, transparent 100%);
            }

            .step-connector::after {
                content: '';
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                border: 6px solid transparent;
                border-left-color: var(--accent);
            }

            .step-card:last-child .step-connector {
                display: none;
            }
        }

        /* ========================================
           SCROLL-TRIGGERED ANIMATIONS
           ======================================== */

        /* Base state for animated elements */
        .animate-on-scroll {
            opacity: 0;
            transform: translateY(24px);
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        .animate-on-scroll.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Staggered delays for grid items */
        .feature-card:nth-child(1) { transition-delay: 0.05s; }
        .feature-card:nth-child(2) { transition-delay: 0.1s; }
        .feature-card:nth-child(3) { transition-delay: 0.15s; }
        .feature-card:nth-child(4) { transition-delay: 0.2s; }
        .feature-card:nth-child(5) { transition-delay: 0.25s; }
        .feature-card:nth-child(6) { transition-delay: 0.3s; }

        .step-card:nth-child(1) { transition-delay: 0.1s; }
        .step-card:nth-child(2) { transition-delay: 0.2s; }
        .step-card:nth-child(3) { transition-delay: 0.3s; }

        .faq-item:nth-child(1) { transition-delay: 0.05s; }
        .faq-item:nth-child(2) { transition-delay: 0.1s; }
        .faq-item:nth-child(3) { transition-delay: 0.15s; }
        .faq-item:nth-child(4) { transition-delay: 0.2s; }
        .faq-item:nth-child(5) { transition-delay: 0.25s; }
        .faq-item:nth-child(6) { transition-delay: 0.3s; }

        /* Icon hover scale - refined */
        .feature-icon {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .feature-card:hover .feature-icon {
            transform: scale(1.08);
        }

        /* Step number animation - refined */
        .step-number {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .step-card:hover .step-number {
            transform: scale(1.08);
        }

        /* Privacy shield - subtle glow */
        .shield-icon {
            transition: filter 0.5s ease;
        }

        .privacy-container:hover .shield-icon {
            filter: drop-shadow(0 0 40px rgba(0, 255, 255, 0.5));
        }

        /* Mobile touch targets */
        @media (max-width: 768px) {
            .btn {
                min-height: 48px;
                padding: 0.875rem 1.5rem;
            }

            .btn-primary {
                font-size: 0.95rem;
                padding: 1rem 1.75rem;
            }

            .faq-question {
                min-height: 56px;
                padding: 1rem 1.25rem;
            }

            .back-to-top {
                bottom: 1.5rem;
                right: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Scroll Progress Bar -->
    <div class="scroll-progress" id="scrollProgress"></div>

    <!-- Canvas - First child of body -->
    <canvas id="bg-canvas"></canvas>

    <!-- CRT Scanline Overlay -->
    <div class="scanline-overlay"></div>


    <!-- Status indicator -->
    <div class="status-indicator">
        <div class="status-dot"></div>
        <span>Core Active</span>
    </div>

    <!-- Back to Top Button -->
    <button class="back-to-top" id="backToTop" aria-label="Back to top">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="18 15 12 9 6 15"></polyline>
        </svg>
    </button>


    <div class="content">
        <section class="hero" id="hero">
            <div class="hero-content">
                <div class="logo-container">
                    <div class="logo-glow"></div>
                    <svg class="logo" viewBox="0 0 128 128" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect width="128" height="128" fill="#0a0a0a" rx="20"/>
                        <defs>
                            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="2" result="blur"/>
                                <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                            </filter>
                        </defs>
                        <g filter="url(#glow)">
                            <path d="M20 36V100C20 106 25 111 31 111H97C103 111 108 106 108 100V46C108 40 103 35 97 35H64L54 22H31C25 22 20 27 20 33V36Z" fill="none" stroke="#00FF88" stroke-width="4" stroke-linejoin="round"/>
                            <rect x="34" y="52" width="20" height="20" fill="#00FF88" rx="3"/>
                            <line x1="34" y1="86" x2="94" y2="86" stroke="#00FF88" stroke-width="3" stroke-linecap="round" opacity="0.6"/>
                            <line x1="34" y1="96" x2="76" y2="96" stroke="#00FF88" stroke-width="2.5" stroke-linecap="round" opacity="0.4"/>
                        </g>
                    </svg>
                </div>
                <h1 class="headline">Tame Your<br><span class="headline-accent">Browser Chaos</span></h1>
                <p class="subheadline">Stop wasting hours on tab overload. AI organizes 100+ tabs in seconds, so you can focus on what matters.</p>
                <div class="cta-group">
                    <a href="https://chromewebstore.google.com/detail/tabeater/khehjgmppbfpmibjcjeffbndjcnbogfj" class="btn btn-primary cta-track" target="_blank">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4"/><line x1="21.17" y1="8" x2="12" y2="8"/><line x1="3.95" y1="6.06" x2="8.54" y2="14"/><line x1="10.88" y1="21.94" x2="15.46" y2="14"/></svg>
                        Start Free Trial
                    </a>
                    <a href="#features" class="btn btn-secondary">See Features</a>
                </div>
                <!-- Trust Badge -->
                <div class="trust-badge">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                    <span>No signup required</span>
                    <span>â€¢</span>
                    <span>Your API key, your AI</span>
                </div>
                <!-- Chrome Badge -->
                <div class="chrome-badge">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4"/></svg>
                    Chrome Extension
                </div>
            </div>
            <div class="scroll-indicator">
                <span>Scroll</span>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M19 12l-7 7-7-7"/></svg>
            </div>
        </section>

        <!-- Live Stats Bar - Minimalist -->
        <section class="stats-bar">
            <div class="stats-container">
                <div class="stat-item">
                    <div class="stat-value">
                        <span class="live-dot"></span>
                        <span id="page-views">--</span>
                    </div>
                    <div class="stat-label">Visitors</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="today-visits">--</div>
                    <div class="stat-label">Today</div>
                </div>
            </div>
        </section>

        <!-- Live Stats Script - Using Abacus API -->
        <script>
        (function() {
            const ns = 'tabeater-landing';
            const today = new Date().toISOString().split('T')[0].replace(/-/g, '');

            // Total visitors (Abacus API)
            fetch(`https://abacus.jasoncameron.dev/hit/${ns}/visits`)
                .then(r => r.json())
                .then(d => document.getElementById('page-views').textContent = d.value.toLocaleString())
                .catch(() => document.getElementById('page-views').textContent = '--');

            // Today's visitors
            fetch(`https://abacus.jasoncameron.dev/hit/${ns}/daily-${today}`)
                .then(r => r.json())
                .then(d => document.getElementById('today-visits').textContent = d.value)
                .catch(() => document.getElementById('today-visits').textContent = '--');
        })();
        </script>

        <section class="features section-backdrop" id="features">
            <div class="section-header">
                <div class="section-label">// Features</div>
                <h2 class="section-title">Powerful Tab Management Features</h2>
            </div>
            <div class="features-grid">
                <div class="feature-card animate-on-scroll">
                    <div class="feature-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg></div>
                    <h3>Smart Organize</h3>
                    <p>Auto-group tabs by domain and topic. Turn clutter into clarity with one click.</p>
                </div>
                <div class="feature-card animate-on-scroll">
                    <div class="feature-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="6" width="20" height="12" rx="2"/><path d="M12 12h.01M17 12h.01M7 12h.01"/></svg></div>
                    <h3>Duplicate Detection</h3>
                    <p>Instantly find and close duplicate tabs. Free up memory and reduce browser bloat.</p>
                </div>
                <div class="feature-card animate-on-scroll">
                    <div class="feature-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></div>
                    <h3>Auto-Pilot Mode</h3>
                    <p>Set it and forget it. TabEater continuously organizes new tabs in the background.</p>
                </div>
                <div class="feature-card animate-on-scroll">
                    <div class="feature-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg></div>
                    <h3>Tab Chat</h3>
                    <p>Ask questions about your open tabs. Get AI-powered insights without reading every page.</p>
                </div>
                <div class="feature-card animate-on-scroll">
                    <div class="feature-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M9 3v18"/></svg></div>
                    <h3>Side Panel</h3>
                    <p>Full command center in Chrome's side panel. Manage tabs without leaving your page.</p>
                </div>
                <div class="feature-card animate-on-scroll">
                    <div class="feature-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 1v6M12 17v6M4.22 4.22l4.24 4.24M15.54 15.54l4.24 4.24M1 12h6M17 12h6M4.22 19.78l4.24-4.24M15.54 8.46l4.24-4.24"/></svg></div>
                    <h3>Multiple AI Providers</h3>
                    <p>Bring your own API key. Works with OpenAI, Google Gemini, and Anthropic Claude.</p>
                </div>
            </div>
        </section>

        <section class="privacy section-backdrop">
            <div class="privacy-container">
                <div class="privacy-visual">
                    <svg class="shield-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><path d="M9 12l2 2 4-4" stroke-width="2"/></svg>
                </div>
                <div class="privacy-content">
                    <h2>Privacy Focused</h2>
                    <p>Your API keys and preferences stay on your device. AI calls go directly to providers.</p>
                    <ul class="privacy-list">
                        <li><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>No data collection or tracking by TabEater</li>
                        <li><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>Direct API calls to your chosen provider</li>
                        <li><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>API keys stored locally in your browser</li>
                        <li><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>Open source â€” audit the code yourself</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="providers section-backdrop">
            <div class="providers-container">
                <div class="providers-label">// Powered By</div>
                <div class="providers-grid">
                    <div class="provider"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>Google Gemini</div>
                    <div class="provider"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M22.28 9.82a5.98 5.98 0 0 0-.52-4.91 6.05 6.05 0 0 0-6.51-2.9A6.07 6.07 0 0 0 4.98 4.18a5.98 5.98 0 0 0-4 2.9 6.05 6.05 0 0 0 .74 7.1 5.98 5.98 0 0 0 .51 4.91 6.05 6.05 0 0 0 6.51 2.9 5.98 5.98 0 0 0 4.5 2.01 6.06 6.06 0 0 0 5.77-4.21 5.99 5.99 0 0 0 4-2.9 6.06 6.06 0 0 0-.75-7.07z"/></svg>OpenAI GPT</div>
                    <div class="provider"><svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10"/><path d="M8 12h8M12 8v8" stroke="#000" stroke-width="2"/></svg>Anthropic Claude</div>
                </div>
            </div>
        </section>

        <section class="how-it-works section-backdrop" id="how-it-works">
            <div class="section-header">
                <div class="section-label">// How It Works</div>
                <h2 class="section-title">Get organized in 3 simple steps</h2>
            </div>
            <div class="steps-grid">
                <div class="step-card animate-on-scroll">
                    <div class="step-number">1</div>
                    <h3>Install the Extension</h3>
                    <p>Add TabEater to Chrome from the Web Store. No account required â€” just install and go.</p>
                    <div class="step-connector"></div>
                </div>
                <div class="step-card animate-on-scroll">
                    <div class="step-number">2</div>
                    <h3>Connect Your AI</h3>
                    <p>Add your API key from OpenAI, Google Gemini, or Anthropic Claude. Your key stays local.</p>
                    <div class="step-connector"></div>
                </div>
                <div class="step-card animate-on-scroll">
                    <div class="step-number">3</div>
                    <h3>Organize Your Tabs</h3>
                    <p>Click to organize, enable auto-pilot, or chat with AI about your open tabs. It's that simple.</p>
                </div>
            </div>
        </section>

        <section class="faq section-backdrop" id="faq">
            <div class="section-header">
                <div class="section-label">// FAQ</div>
                <h2 class="section-title">Frequently Asked Questions</h2>
            </div>
            <div class="faq-container">
                <div class="faq-item animate-on-scroll">
                    <div class="faq-question">
                        <span>What is the best Chrome extension for managing too many tabs?</span>
                        <span class="faq-toggle"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                    </div>
                    <div class="faq-answer">
                        <p>TabEater is an AI-powered Chrome extension that helps you manage hundreds of tabs effortlessly. It automatically groups tabs by topic, detects and closes duplicates, and lets you chat with AI about your open pages. Unlike other tab managers, TabEater uses AI to intelligently organize your tabs based on content, not just domain.</p>
                    </div>
                </div>
                <div class="faq-item animate-on-scroll">
                    <div class="faq-question">
                        <span>How do I organize my Chrome tabs automatically?</span>
                        <span class="faq-toggle"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                    </div>
                    <div class="faq-answer">
                        <p>Install TabEater from the Chrome Web Store and enable Auto-Pilot mode. TabEater will automatically organize new tabs in the background, group them by topic, and close duplicates. You can also click the extension icon to manually organize all tabs with one click.</p>
                    </div>
                </div>
                <div class="faq-item animate-on-scroll">
                    <div class="faq-question">
                        <span>Is TabEater free to use?</span>
                        <span class="faq-toggle"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                    </div>
                    <div class="faq-answer">
                        <p>TabEater offers a 7-day free trial with full access. After that, you can get lifetime PRO access for just $6 AUD (one-time payment). You bring your own API key from OpenAI, Google Gemini, or Anthropic Claude.</p>
                    </div>
                </div>
                <div class="faq-item animate-on-scroll">
                    <div class="faq-question">
                        <span>How do I close duplicate tabs in Chrome?</span>
                        <span class="faq-toggle"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                    </div>
                    <div class="faq-answer">
                        <p>With TabEater, click the extension icon and select 'Find Duplicates'. TabEater will instantly scan all your open tabs and identify exact duplicates. You can then close them with one click, freeing up memory and reducing browser clutter.</p>
                    </div>
                </div>
                <div class="faq-item animate-on-scroll">
                    <div class="faq-question">
                        <span>Does TabEater collect my browsing data?</span>
                        <span class="faq-toggle"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                    </div>
                    <div class="faq-answer">
                        <p>No, TabEater does not collect any browsing data. Your API keys and preferences are stored locally in your browser. AI requests go directly from your browser to your chosen provider (OpenAI, Gemini, or Claude). TabEater is also open source so you can audit the code yourself.</p>
                    </div>
                </div>
                <div class="faq-item animate-on-scroll">
                    <div class="faq-question">
                        <span>What AI providers does TabEater support?</span>
                        <span class="faq-toggle"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                    </div>
                    <div class="faq-answer">
                        <p>TabEater supports multiple AI providers: OpenAI (GPT-4, GPT-3.5), Google Gemini, and Anthropic Claude. You can choose your preferred provider in the settings and switch between them anytime.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="cta-section section-backdrop">
            <h2>Ready to take control of your browser tabs?</h2>
            <p>Join thousands of users who've tamed their tab chaos. 7-day free trial, no account needed.</p>
            <a href="https://chromewebstore.google.com/detail/tabeater/khehjgmppbfpmibjcjeffbndjcnbogfj" class="btn btn-primary cta-track" target="_blank">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4"/><line x1="21.17" y1="8" x2="12" y2="8"/><line x1="3.95" y1="6.06" x2="8.54" y2="14"/><line x1="10.88" y1="21.94" x2="15.46" y2="14"/></svg>
                Start Free Trial
            </a>
        </section>

        <footer class="footer">
            <div class="footer-links">
                <a href="https://github.com/anonx00/tabeater">GitHub</a>
                <a href="https://github.com/anonx00/tabeater/blob/main/LICENSE">ISC License</a>
                <a href="https://github.com/anonx00/tabeater/issues">Support</a>
            </div>
            <div class="footer-copy">Â© 2025 TabEater. Open source under ISC License.</div>
        </footer>
    </div>

    <!-- Google Analytics Click Tracking & UI Interactions -->
    <script>
        // Track CTA button clicks with GA4
        document.querySelectorAll('.cta-track').forEach((btn, index) => {
            btn.addEventListener('click', function(e) {
                // Send event to Google Analytics 4
                if (typeof gtag === 'function') {
                    gtag('event', 'cta_click', {
                        'button_location': index === 0 ? 'hero' : 'footer',
                        'button_text': this.textContent.trim(),
                        'link_url': this.href
                    });

                    // Also track as a conversion event
                    gtag('event', 'conversion', {
                        'send_to': 'G-Y6MEHQB9CZ',
                        'event_category': 'CTA',
                        'event_label': 'Chrome Web Store Click'
                    });
                }
            });
        });

        // FAQ Accordion
        document.querySelectorAll('.faq-question').forEach(question => {
            question.addEventListener('click', () => {
                const item = question.parentElement;
                const wasActive = item.classList.contains('active');

                // Close all other items
                document.querySelectorAll('.faq-item').forEach(faq => {
                    faq.classList.remove('active');
                });

                // Toggle current item
                if (!wasActive) {
                    item.classList.add('active');
                }
            });
        });

        // Scroll Progress Bar
        const scrollProgress = document.getElementById('scrollProgress');
        const backToTop = document.getElementById('backToTop');

        window.addEventListener('scroll', () => {
            const scrollTop = window.scrollY;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / docHeight) * 100;

            // Update progress bar
            scrollProgress.style.width = scrollPercent + '%';

            // Show/hide back to top button (after 30% scroll)
            if (scrollPercent > 30) {
                backToTop.classList.add('visible');
            } else {
                backToTop.classList.remove('visible');
            }
        }, { passive: true });

        // Back to Top button click
        backToTop.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Button ripple effect
        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                const rect = this.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const ripple = document.createElement('span');
                ripple.style.cssText = `
                    position: absolute;
                    background: rgba(255,255,255,0.3);
                    border-radius: 50%;
                    width: 100px;
                    height: 100px;
                    left: ${x - 50}px;
                    top: ${y - 50}px;
                    transform: scale(0);
                    animation: ripple 0.6s ease-out;
                    pointer-events: none;
                `;
                this.style.position = 'relative';
                this.style.overflow = 'hidden';
                this.appendChild(ripple);

                setTimeout(() => ripple.remove(), 600);
            });
        });

        // Add ripple animation keyframes dynamically
        const style = document.createElement('style');
        style.textContent = `
            @keyframes ripple {
                to {
                    transform: scale(4);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);

        // Scroll-triggered animations with Intersection Observer
        const animateOnScroll = () => {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            });

            document.querySelectorAll('.animate-on-scroll').forEach(el => {
                observer.observe(el);
            });
        };

        // Run after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', animateOnScroll);
        } else {
            animateOnScroll();
        }
    </script>

    <!-- Three.js - Deferred Loading for Performance -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    // ============================================
    // TRON BIKE 3D ANIMATION
    // Red neon aesthetic with GLB model
    // ============================================

    const initThreeJS = () => {
        import('three').then(async (THREE) => {
            const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');

            const isMobile = window.innerWidth < 768;
            const canvas = document.getElementById('bg-canvas');

            // TRON color palette - multiple bike colors
            const TRON = {
                // Grid colors
                gridColor: 0xff1a1a,
                gridDark: 0x330000,
                // Bike colors (classic TRON)
                cyan: 0x00ffff,
                cyanBright: 0x66ffff,
                orange: 0xff6600,
                orangeBright: 0xffaa44,
                yellow: 0xffff00,
                yellowBright: 0xffff66,
                purple: 0xcc00ff,
                purpleBright: 0xdd66ff,
                red: 0xff2a2a,
                redBright: 0xff6666,
                white: 0xffffff
            };

            // Bike configurations - TRON race formation with wide lane spread
            // Bikes closer together for racing/collision feel
            const bikeConfigs = [
                { color: TRON.cyan, bright: TRON.cyanBright, x: 0, z: 5, speed: 1.0, lane: 0 },
                { color: TRON.orange, bright: TRON.orangeBright, x: -12, z: -5, speed: 0.95, lane: -1 },
                { color: TRON.yellow, bright: TRON.yellowBright, x: 12, z: -3, speed: 0.97, lane: 1 },
                { color: TRON.purple, bright: TRON.purpleBright, x: -6, z: -12, speed: 0.92, lane: 0 },
                { color: TRON.red, bright: TRON.redBright, x: 18, z: -15, speed: 0.90, lane: 2 }
            ];

            // ============================================
            // RENDERER - Cinematic dark style
            // ============================================
            const renderer = new THREE.WebGLRenderer({
                canvas,
                alpha: true,
                antialias: !isMobile,
                powerPreference: isMobile ? 'low-power' : 'high-performance'
            });
            renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.7; // Balanced exposure

            // ============================================
            // SCENE & CAMERA - Low dramatic angle
            // ============================================
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000005, 0.006); // Denser fog for cinematic depth

            const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 70);
            camera.lookAt(0, 0, -20);

            // Camera parameters - cinematic sweep + user controls
            const cameraOrbit = {
                radius: 75,
                height: 7,
                speed: 0.025,
                lookAtHeight: 0
            };

            // User camera control state
            const userCamera = {
                angleOffset: 0,
                heightOffset: 0,
                zoom: 1,
                isDragging: false,
                lastX: 0,
                lastY: 0,
                autoRotate: true
            };

            // Mouse/touch drag for camera rotation
            canvas.addEventListener('mousedown', (e) => {
                userCamera.isDragging = true;
                userCamera.lastX = e.clientX;
                userCamera.lastY = e.clientY;
                userCamera.autoRotate = false;
                canvas.style.cursor = 'grabbing';
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!userCamera.isDragging) return;
                const deltaX = e.clientX - userCamera.lastX;
                const deltaY = e.clientY - userCamera.lastY;
                userCamera.angleOffset += deltaX * 0.005;
                userCamera.heightOffset += deltaY * 0.1;
                userCamera.heightOffset = Math.max(-20, Math.min(30, userCamera.heightOffset));
                userCamera.lastX = e.clientX;
                userCamera.lastY = e.clientY;
            });

            canvas.addEventListener('mouseup', () => {
                userCamera.isDragging = false;
                canvas.style.cursor = 'grab';
                // Resume auto-rotate after 3 seconds of no interaction
                setTimeout(() => { if (!userCamera.isDragging) userCamera.autoRotate = true; }, 3000);
            });

            canvas.addEventListener('mouseleave', () => {
                userCamera.isDragging = false;
                canvas.style.cursor = 'grab';
            });

            // Touch support
            canvas.addEventListener('touchstart', (e) => {
                userCamera.isDragging = true;
                userCamera.lastX = e.touches[0].clientX;
                userCamera.lastY = e.touches[0].clientY;
                userCamera.autoRotate = false;
            }, { passive: true });

            canvas.addEventListener('touchmove', (e) => {
                if (!userCamera.isDragging) return;
                const deltaX = e.touches[0].clientX - userCamera.lastX;
                const deltaY = e.touches[0].clientY - userCamera.lastY;
                userCamera.angleOffset += deltaX * 0.005;
                userCamera.heightOffset += deltaY * 0.1;
                userCamera.heightOffset = Math.max(-20, Math.min(30, userCamera.heightOffset));
                userCamera.lastX = e.touches[0].clientX;
                userCamera.lastY = e.touches[0].clientY;
            }, { passive: true });

            canvas.addEventListener('touchend', () => {
                userCamera.isDragging = false;
                setTimeout(() => { if (!userCamera.isDragging) userCamera.autoRotate = true; }, 3000);
            });

            // Scroll/pinch for zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                userCamera.zoom += e.deltaY * 0.001;
                userCamera.zoom = Math.max(0.5, Math.min(2.5, userCamera.zoom));
            }, { passive: false });

            canvas.style.cursor = 'grab';

            // ============================================
            // LIGHTING - Dramatic and minimal
            // ============================================
            const ambientLight = new THREE.AmbientLight(0x030308, 0.3);
            scene.add(ambientLight);

            // Subtle colored rim lights for atmosphere
            const cyanLight = new THREE.PointLight(TRON.cyan, 2, 120);
            cyanLight.position.set(-50, 15, -50);
            scene.add(cyanLight);

            const orangeLight = new THREE.PointLight(TRON.orange, 2, 120);
            orangeLight.position.set(50, 15, -50);
            scene.add(orangeLight);

            const purpleLight = new THREE.PointLight(TRON.purple, 1.5, 100);
            purpleLight.position.set(0, 20, -80);
            scene.add(purpleLight);

            const redLight = new THREE.PointLight(TRON.red, 0.8, 60);
            redLight.position.set(0, 3, 30);
            scene.add(redLight);

            // ============================================
            // THE GRID - Enhanced racing grid with speed lines
            // ============================================
            const gridSize = 250;
            const gridDivisions = isMobile ? 50 : 100;

            // Create two grids for seamless scrolling - brighter for racing
            const gridHelper1 = new THREE.GridHelper(gridSize, gridDivisions, TRON.cyan, TRON.gridDark);
            gridHelper1.material.opacity = 0.6;
            gridHelper1.material.transparent = true;
            gridHelper1.position.z = 0;
            scene.add(gridHelper1);

            // Second grid for seamless loop
            const gridHelper2 = new THREE.GridHelper(gridSize, gridDivisions, TRON.cyan, TRON.gridDark);
            gridHelper2.material.opacity = 0.6;
            gridHelper2.material.transparent = true;
            gridHelper2.position.z = -gridSize;
            scene.add(gridHelper2);

            // Grid speed for movement illusion - FAST racing feel
            const gridSpeed = 65; // Much faster for intense racing

            // ============================================
            // RACING LANE LINES - perspective speed lines
            // ============================================
            const laneColors = [TRON.cyan, TRON.orange, TRON.purple];
            const laneLines = [];
            for (let i = -2; i <= 2; i++) {
                const laneGeo = new THREE.PlaneGeometry(0.15, 500);
                const laneMat = new THREE.MeshBasicMaterial({
                    color: laneColors[Math.abs(i) % laneColors.length],
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const lane = new THREE.Mesh(laneGeo, laneMat);
                lane.rotation.x = -Math.PI / 2;
                lane.position.set(i * 18, 0.01, -100);
                scene.add(lane);
                laneLines.push(lane);
            }

            // Center racing stripe - bright accent
            const centerStripeGeo = new THREE.PlaneGeometry(0.3, 500);
            const centerStripeMat = new THREE.MeshBasicMaterial({
                color: TRON.cyan,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const centerStripe = new THREE.Mesh(centerStripeGeo, centerStripeMat);
            centerStripe.rotation.x = -Math.PI / 2;
            centerStripe.position.set(0, 0.015, -100);
            scene.add(centerStripe);

            // ============================================
            // REFLECTIVE GROUND PLANE - darker for contrast
            // ============================================
            const groundGeo = new THREE.PlaneGeometry(500, 500);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x000004,
                metalness: 0.95,
                roughness: 0.2,
                transparent: true,
                opacity: 0.7
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            scene.add(ground);

            // Horizon glow effect - brighter
            const horizonGeo = new THREE.PlaneGeometry(500, 60);
            const horizonMat = new THREE.MeshBasicMaterial({
                color: TRON.cyan,
                transparent: true,
                opacity: 0.12,
                side: THREE.DoubleSide
            });
            const horizon = new THREE.Mesh(horizonGeo, horizonMat);
            horizon.position.set(0, 30, -220);
            scene.add(horizon);

            // Speed blur lines at edges
            for (let side = -1; side <= 1; side += 2) {
                for (let j = 0; j < 3; j++) {
                    const blurGeo = new THREE.PlaneGeometry(0.08, 400);
                    const blurMat = new THREE.MeshBasicMaterial({
                        color: TRON.cyan,
                        transparent: true,
                        opacity: 0.2 - j * 0.05,
                        side: THREE.DoubleSide
                    });
                    const blur = new THREE.Mesh(blurGeo, blurMat);
                    blur.rotation.x = -Math.PI / 2;
                    blur.position.set(side * (50 + j * 8), 0.01, -100);
                    scene.add(blur);
                }
            }

            // ============================================
            // LOAD MULTIPLE BIKES
            // ============================================
            const loader = new GLTFLoader();
            const bikes = [];
            const bikeCount = isMobile ? 3 : 5;

            loader.load('bike.glb', (gltf) => {
                // Create multiple bikes - keep original model colors
                for (let i = 0; i < bikeCount; i++) {
                    const config = bikeConfigs[i];
                    const bike = gltf.scene.clone();

                    // Scale bikes LARGER for visibility
                    bike.scale.set(4.5, 4.5, 4.5);
                    bike.position.set(config.x, 0.8, config.z);
                    bike.rotation.y = Math.PI / 2; // Face forward

                    // Enhanced bike glow - headlights and engine
                    bike.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material = child.material.clone();
                            child.material.emissive = new THREE.Color(config.color);
                            child.material.emissiveIntensity = 0.35; // Stronger glow
                        }
                    });

                    // Stronger bike light for light bleeding effect
                    const bikeLight = new THREE.PointLight(config.color, 4, 35);
                    bikeLight.position.set(0, 1.5, -3);
                    bike.add(bikeLight);

                    // Front headlight glow
                    const headLight = new THREE.PointLight(config.bright, 2, 15);
                    headLight.position.set(0, 1, 3);
                    bike.add(headLight);

                    // ============================================
                    // TRON-STYLE WALL TRAIL - Sleek racing trail
                    // ============================================
                    const trailLength = 55; // Compact, sleek trail
                    const trailHeight = 1.0; // Thinner profile

                    // Main vertical wall trail - sharp neon core
                    const trailGeo = new THREE.PlaneGeometry(trailLength, trailHeight);
                    const trailMat = new THREE.MeshBasicMaterial({
                        color: config.bright,
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide
                    });
                    const trail = new THREE.Mesh(trailGeo, trailMat);
                    trail.rotation.y = Math.PI / 2;
                    trail.position.set(0, trailHeight / 2 + 0.1, -trailLength / 2);
                    bike.add(trail);

                    // Inner glow - tight bright edge
                    const innerGlowGeo = new THREE.PlaneGeometry(trailLength, trailHeight * 1.15);
                    const innerGlowMat = new THREE.MeshBasicMaterial({
                        color: config.bright,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide
                    });
                    const innerGlow = new THREE.Mesh(innerGlowGeo, innerGlowMat);
                    innerGlow.rotation.y = Math.PI / 2;
                    innerGlow.position.set(0, trailHeight / 2 + 0.1, -trailLength / 2 + 0.05);
                    bike.add(innerGlow);

                    // Outer glow - subtle halo
                    const glowGeo = new THREE.PlaneGeometry(trailLength, trailHeight * 1.6);
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: config.color,
                        transparent: true,
                        opacity: 0.12,
                        side: THREE.DoubleSide
                    });
                    const glow = new THREE.Mesh(glowGeo, glowMat);
                    glow.rotation.y = Math.PI / 2;
                    glow.position.set(0, trailHeight / 2 + 0.1, -trailLength / 2 - 0.05);
                    bike.add(glow);

                    // Ground reflection strip - tight and bright
                    const groundGlowGeo = new THREE.PlaneGeometry(trailLength, 2.0);
                    const groundGlowMat = new THREE.MeshBasicMaterial({
                        color: config.color,
                        transparent: true,
                        opacity: 0.25,
                        side: THREE.DoubleSide
                    });
                    const groundGlow = new THREE.Mesh(groundGlowGeo, groundGlowMat);
                    groundGlow.rotation.x = -Math.PI / 2;
                    groundGlow.position.set(0, 0.02, -trailLength / 2);
                    bike.add(groundGlow);

                    // Trail light - focused glow
                    const trailLight = new THREE.PointLight(config.color, 4, 40);
                    trailLight.position.set(0, 0.8, -15);
                    bike.add(trailLight);

                    scene.add(bike);

                    bikes.push({
                        mesh: bike,
                        trail: trail,
                        glow: glow,
                        groundGlow: groundGlow,
                        trailLight: trailLight,
                        config: config,
                        baseX: config.x,
                        baseZ: config.z,
                        time: Math.random() * Math.PI * 2,
                        targetRotZ: 0,
                        currentRotZ: 0,
                        // Physics-based movement
                        velocity: { x: 0, z: 0 },
                        targetVelocity: { x: 0, z: 0 },
                        acceleration: 0.12 + Math.random() * 0.08,
                        maxSpeed: 6 + Math.random() * 3,
                        changeTimer: 0,
                        changeInterval: 60 + Math.floor(Math.random() * 80),
                        racingIntensity: 0.5 + Math.random() * 0.5,
                        lastVelocity: { x: 0, z: 0 }
                    });
                }
            }, undefined, (error) => {
                console.error('Error loading bike model:', error);
            });

            // ============================================
            // PARTICLES - Enhanced with varied sizes and streaks
            // ============================================
            const particleCount = isMobile ? 250 : 800;
            const particleGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const velocities = new Float32Array(particleCount * 3);

            const particleColors = [
                new THREE.Color(TRON.cyan),
                new THREE.Color(TRON.orange),
                new THREE.Color(TRON.purple),
                new THREE.Color(TRON.yellow),
                new THREE.Color(TRON.red)
            ];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 1] = Math.random() * 50;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;

                const color = particleColors[Math.floor(Math.random() * particleColors.length)];
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                // Varied sizes - some larger bright stars, some small dust
                sizes[i] = Math.random() < 0.1 ? 0.5 + Math.random() * 0.5 : 0.08 + Math.random() * 0.15;

                velocities[i * 3] = (Math.random() - 0.5) * 0.04;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.02;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.04;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const particleMat = new THREE.PointsMaterial({
                size: isMobile ? 0.25 : 0.2,
                transparent: true,
                opacity: 0.9,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const particles = new THREE.Points(particleGeo, particleMat);
            scene.add(particles);

            // ============================================
            // STREAK PARTICLES - Shooting star effects
            // ============================================
            const streakCount = isMobile ? 5 : 15;
            const streaks = [];
            for (let i = 0; i < streakCount; i++) {
                const streakGeo = new THREE.BufferGeometry();
                const streakPositions = new Float32Array(6); // 2 points per streak
                streakGeo.setAttribute('position', new THREE.BufferAttribute(streakPositions, 3));

                const streakMat = new THREE.LineBasicMaterial({
                    color: particleColors[Math.floor(Math.random() * particleColors.length)],
                    transparent: true,
                    opacity: 0,
                    blending: THREE.AdditiveBlending
                });

                const streak = new THREE.Line(streakGeo, streakMat);
                scene.add(streak);

                streaks.push({
                    mesh: streak,
                    active: false,
                    life: 0,
                    speed: 2 + Math.random() * 3,
                    x: 0, y: 0, z: 0,
                    dx: 0, dy: 0, dz: 0
                });
            }

            // ============================================
            // SPARK/CRASH EFFECTS - ENHANCED with varied particles
            // ============================================
            const sparkPool = [];
            const maxSparks = 150; // 3x more sparks
            for (let i = 0; i < maxSparks; i++) {
                // Varied spark sizes for visual interest
                const sizeType = Math.random();
                let sparkGeo, baseOpacity;
                if (sizeType < 0.5) {
                    // Small dust particles
                    sparkGeo = new THREE.SphereGeometry(0.06, 3, 3);
                    baseOpacity = 0.9;
                } else if (sizeType < 0.85) {
                    // Medium sparks
                    sparkGeo = new THREE.SphereGeometry(0.12, 4, 4);
                    baseOpacity = 1.0;
                } else {
                    // Large bright flares
                    sparkGeo = new THREE.OctahedronGeometry(0.18);
                    baseOpacity = 1.0;
                }

                const sparkMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0
                });
                const spark = new THREE.Mesh(sparkGeo, sparkMat);
                scene.add(spark);
                sparkPool.push({
                    mesh: spark,
                    active: false,
                    life: 0,
                    maxLife: 1.0,
                    vx: 0, vy: 0, vz: 0,
                    rotVel: { x: 0, y: 0, z: 0 },
                    baseOpacity: baseOpacity,
                    sizeType: sizeType
                });
            }

            // Enhanced spark spawning with more variety
            function spawnSparks(x, y, z, color, count = 12, intensity = 1.0) {
                let spawned = 0;
                for (let i = 0; i < sparkPool.length && spawned < count; i++) {
                    const spark = sparkPool[i];
                    if (!spark.active) {
                        spark.active = true;
                        spark.maxLife = 0.8 + Math.random() * 0.6;
                        spark.life = spark.maxLife;
                        spark.mesh.position.set(x, y, z);
                        spark.mesh.material.color.set(color);
                        spark.mesh.material.opacity = spark.baseOpacity;

                        // Enhanced velocity - more spread and speed
                        const angle = Math.random() * Math.PI * 2;
                        const elevation = Math.random() * Math.PI - Math.PI / 2;
                        const speed = (2 + Math.random() * 4) * intensity;

                        spark.vx = Math.cos(elevation) * Math.cos(angle) * speed;
                        spark.vy = Math.sin(elevation) * speed + Math.random() * 2.5;
                        spark.vz = Math.cos(elevation) * Math.sin(angle) * speed;

                        // Random rotation for larger particles
                        spark.rotVel.x = (Math.random() - 0.5) * 0.3;
                        spark.rotVel.y = (Math.random() - 0.5) * 0.3;
                        spark.rotVel.z = (Math.random() - 0.5) * 0.3;

                        spawned++;
                    }
                }
            }

            // ============================================
            // POST-PROCESSING (Desktop only)
            // ============================================
            let composer = null;
            if (!isMobile) {
                const { EffectComposer } = await import('three/addons/postprocessing/EffectComposer.js');
                const { RenderPass } = await import('three/addons/postprocessing/RenderPass.js');
                const { UnrealBloomPass } = await import('three/addons/postprocessing/UnrealBloomPass.js');

                composer = new EffectComposer(renderer);
                composer.addPass(new RenderPass(scene, camera));

                // ENHANCED TRON neon bloom effect
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    2.0,   // strength - enhanced glow
                    0.5,   // radius - wider spread
                    0.15   // threshold - catches more bright areas
                );
                composer.addPass(bloomPass);

                // Store for dynamic updates
                window.bloomPass = bloomPass;
            }

            // ============================================
            // ANIMATION LOOP with Performance Optimizations
            // ============================================
            let time = 0;
            let isVisible = true;
            let lastFrameTime = 0;
            const targetFPS = isMobile ? 30 : 60;
            const frameInterval = 1000 / targetFPS;

            // Visibility check - pause animation when off-screen
            const observer = new IntersectionObserver((entries) => {
                isVisible = entries[0].isIntersecting;
            }, { threshold: 0.1 });
            observer.observe(canvas);

            function animate(currentTime) {
                requestAnimationFrame(animate);

                // Skip if not visible (saves CPU/GPU)
                if (!isVisible) return;

                // FPS throttling for mobile
                if (isMobile) {
                    const elapsed = currentTime - lastFrameTime;
                    if (elapsed < frameInterval) return;
                    lastFrameTime = currentTime - (elapsed % frameInterval);
                }

                time += 0.016;

                // Camera movement: auto-rotate + user controls
                const autoAngle = userCamera.autoRotate ? time * cameraOrbit.speed : 0;
                const totalAngle = autoAngle + userCamera.angleOffset;
                const effectiveRadius = cameraOrbit.radius * userCamera.zoom;

                camera.position.x = Math.sin(totalAngle) * effectiveRadius;
                camera.position.z = Math.cos(totalAngle) * effectiveRadius;
                camera.position.y = cameraOrbit.height + userCamera.heightOffset + (userCamera.autoRotate ? Math.sin(time * 0.15) * 1.5 : 0);
                camera.lookAt(0, cameraOrbit.lookAtHeight, -15);

                // Animate grid - scrolling to create movement illusion
                gridHelper1.position.z += gridSpeed * 0.016;
                gridHelper2.position.z += gridSpeed * 0.016;

                // Reset grids for seamless loop
                if (gridHelper1.position.z > gridSize) {
                    gridHelper1.position.z = gridHelper2.position.z - gridSize;
                }
                if (gridHelper2.position.z > gridSize) {
                    gridHelper2.position.z = gridHelper1.position.z - gridSize;
                }

                // Animate bikes - ENHANCED physics-based racing dynamics
                bikes.forEach((bike, i) => {
                    bike.time += 0.025 * bike.config.speed;
                    bike.changeTimer++;

                    // Physics-based movement: change behavior periodically
                    if (bike.changeTimer > bike.changeInterval) {
                        const behavior = Math.random();
                        if (behavior < 0.35) {
                            // Aggressive lane takeover
                            bike.targetVelocity.z = 10 * bike.config.speed * bike.racingIntensity;
                            bike.targetVelocity.x = (Math.random() - 0.5) * 8;
                        } else if (behavior < 0.65) {
                            // Weaving evasion
                            bike.targetVelocity.x = Math.sin(bike.time * 0.4) * 8 * bike.racingIntensity;
                            bike.targetVelocity.z = 6 * bike.config.speed;
                        } else {
                            // Conservative positioning
                            bike.targetVelocity.z = 4 * bike.config.speed;
                            bike.targetVelocity.x = Math.cos(bike.time * 0.2) * 4;
                        }
                        bike.changeTimer = 0;
                        bike.changeInterval = 50 + Math.floor(Math.random() * 100);
                    }

                    // Smooth velocity interpolation (physics feel)
                    bike.velocity.x += (bike.targetVelocity.x - bike.velocity.x) * bike.acceleration;
                    bike.velocity.z += (bike.targetVelocity.z - bike.velocity.z) * bike.acceleration;

                    // Clamp to max speed
                    const speed = Math.sqrt(bike.velocity.x * bike.velocity.x + bike.velocity.z * bike.velocity.z);
                    if (speed > bike.maxSpeed) {
                        bike.velocity.x = (bike.velocity.x / speed) * bike.maxSpeed;
                        bike.velocity.z = (bike.velocity.z / speed) * bike.maxSpeed;
                    }

                    // Collision avoidance with other bikes
                    let avoidX = 0, avoidZ = 0;
                    bikes.forEach((other, j) => {
                        if (i === j) return;
                        const dx = other.mesh.position.x - bike.mesh.position.x;
                        const dz = other.mesh.position.z - bike.mesh.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < 15) {
                            const force = 1 - (dist / 15);
                            avoidX -= (dx / (dist + 0.1)) * force * 2.5;
                            avoidZ -= (dz / (dist + 0.1)) * force * 2.5;
                        }
                    });
                    bike.velocity.x += avoidX * 0.08;
                    bike.velocity.z += avoidZ * 0.08;

                    // Apply velocity
                    bike.mesh.position.x += bike.velocity.x * 0.016;
                    bike.mesh.position.z += bike.velocity.z * 0.016;

                    // Arena bounds with bounce
                    const boundsX = 35, boundsZ = 45;
                    if (Math.abs(bike.mesh.position.x) > boundsX) {
                        bike.mesh.position.x = Math.sign(bike.mesh.position.x) * boundsX;
                        bike.velocity.x *= -0.6;
                    }
                    if (Math.abs(bike.mesh.position.z) > boundsZ) {
                        bike.mesh.position.z = Math.sign(bike.mesh.position.z) * boundsZ;
                        bike.velocity.z *= -0.6;
                    }

                    // Subtle hover effect
                    bike.mesh.position.y = 0.8 + Math.sin(bike.time * 1.5) * 0.1;

                    // Lean into turns based on velocity
                    const movementAngle = Math.atan2(bike.velocity.x, bike.velocity.z);
                    bike.targetRotZ = -bike.velocity.x * 0.015;
                    bike.currentRotZ += (bike.targetRotZ - bike.currentRotZ) * 0.1;
                    bike.mesh.rotation.z = bike.currentRotZ;

                    // Speed-responsive trail effects
                    const normalizedSpeed = Math.min(speed / bike.maxSpeed, 1.0);
                    bike.trail.material.opacity = 0.6 + normalizedSpeed * 0.25 + Math.sin(bike.time * 2.5) * 0.08;
                    bike.glow.material.opacity = 0.12 + normalizedSpeed * 0.18 + Math.sin(bike.time * 2) * 0.06;
                    if (bike.groundGlow) {
                        bike.groundGlow.material.opacity = 0.12 + normalizedSpeed * 0.12 + Math.sin(bike.time * 3) * 0.04;
                    }
                    if (bike.trailLight) {
                        bike.trailLight.intensity = 4 + normalizedSpeed * 2 + Math.sin(bike.time * 1.8) * 0.6;
                    }

                    // Store velocity for next frame
                    bike.lastVelocity = { x: bike.velocity.x, z: bike.velocity.z };

                    // Enhanced near-collision detection with more sparks
                    bikes.forEach((other, j) => {
                        if (i >= j) return;
                        const dx = bike.mesh.position.x - other.mesh.position.x;
                        const dz = bike.mesh.position.z - other.mesh.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        // Multi-stage collision response
                        if (dist < 22) {
                            const closeness = 1 - (dist / 22);
                            const spawnChance = Math.min(0.35 * closeness, 0.5);

                            if (Math.random() < spawnChance) {
                                const midX = (bike.mesh.position.x + other.mesh.position.x) / 2;
                                const midY = 1.4 + Math.sin(bike.time) * 0.4;
                                const midZ = (bike.mesh.position.z + other.mesh.position.z) / 2;
                                const colors = [bike.config.bright, other.config.bright, bike.config.color, other.config.color];
                                const sparkColor = colors[Math.floor(Math.random() * colors.length)];
                                const sparkCount = 10 + Math.floor(closeness * 15);
                                spawnSparks(midX, midY, midZ, sparkColor, sparkCount, closeness);
                            }
                        }
                    });
                });

                // Animate sparks - ENHANCED physics
                sparkPool.forEach(spark => {
                    if (spark.active) {
                        spark.life -= 0.016 / spark.maxLife;

                        // Physics with air drag
                        spark.mesh.position.x += spark.vx * 0.08;
                        spark.mesh.position.y += spark.vy * 0.08;
                        spark.mesh.position.z += spark.vz * 0.08;
                        spark.vy -= 0.12; // Stronger gravity
                        spark.vx *= 0.97; // Air drag
                        spark.vy *= 0.97;
                        spark.vz *= 0.97;

                        // Rotation for larger particles
                        spark.mesh.rotation.x += spark.rotVel.x;
                        spark.mesh.rotation.y += spark.rotVel.y;
                        spark.mesh.rotation.z += spark.rotVel.z;

                        // Non-linear fade for dramatic effect
                        const lifePercent = Math.max(0, spark.life / spark.maxLife);
                        const fadeOut = Math.pow(lifePercent, 1.5);
                        spark.mesh.material.opacity = spark.baseOpacity * fadeOut;

                        // Slight scale reduction
                        const scale = 0.5 + lifePercent * 0.5;
                        spark.mesh.scale.setScalar(scale);

                        if (spark.life <= 0) {
                            spark.active = false;
                            spark.mesh.material.opacity = 0;
                        }
                    }
                });

                // Animate streaks - shooting star effects
                streaks.forEach((streak, i) => {
                    if (!streak.active && Math.random() < 0.003) {
                        // Spawn new streak
                        streak.active = true;
                        streak.life = 1.0;
                        streak.x = (Math.random() - 0.5) * 150;
                        streak.y = 10 + Math.random() * 40;
                        streak.z = (Math.random() - 0.5) * 150;
                        streak.dx = (Math.random() - 0.5) * 2;
                        streak.dy = -0.5 - Math.random();
                        streak.dz = (Math.random() - 0.5) * 2;
                    }

                    if (streak.active) {
                        streak.life -= 0.02;
                        streak.x += streak.dx * streak.speed;
                        streak.y += streak.dy * streak.speed;
                        streak.z += streak.dz * streak.speed;

                        const positions = streak.mesh.geometry.attributes.position.array;
                        positions[0] = streak.x;
                        positions[1] = streak.y;
                        positions[2] = streak.z;
                        positions[3] = streak.x - streak.dx * 3;
                        positions[4] = streak.y - streak.dy * 3;
                        positions[5] = streak.z - streak.dz * 3;
                        streak.mesh.geometry.attributes.position.needsUpdate = true;

                        streak.mesh.material.opacity = streak.life * 0.8;

                        if (streak.life <= 0) {
                            streak.active = false;
                            streak.mesh.material.opacity = 0;
                        }
                    }
                });

                // Animate particles (using typed array) - larger bounds
                const pos = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    const idx = i * 3;
                    pos[idx] += velocities[idx];
                    pos[idx + 1] += velocities[idx + 1];
                    pos[idx + 2] += velocities[idx + 2];

                    // Reset if out of bounds - larger area
                    if (Math.abs(pos[idx]) > 100) velocities[idx] *= -1;
                    if (pos[idx + 1] > 50 || pos[idx + 1] < 0) velocities[idx + 1] *= -1;
                    if (Math.abs(pos[idx + 2]) > 100) velocities[idx + 2] *= -1;
                }
                particles.geometry.attributes.position.needsUpdate = true;

                // Pulse atmosphere lights
                cyanLight.intensity = 2 + Math.sin(time * 1.5) * 0.5;
                orangeLight.intensity = 2 + Math.cos(time * 1.2) * 0.5;
                purpleLight.intensity = 1.5 + Math.sin(time * 0.8) * 0.3;

                // Pulse grid opacity for racing intensity
                const gridPulse = 0.55 + Math.sin(time * 2) * 0.1;
                gridHelper1.material.opacity = gridPulse;
                gridHelper2.material.opacity = gridPulse;

                // Pulse center stripe
                if (centerStripe) {
                    centerStripe.material.opacity = 0.6 + Math.sin(time * 3) * 0.15;
                }

                // Render
                if (composer) {
                    composer.render();
                } else {
                    renderer.render(scene, camera);
                }
            }

            animate(0);

            // Resize handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if (composer) composer.setSize(window.innerWidth, window.innerHeight);
            }, { passive: true });
        });
    };

    // Use requestIdleCallback for non-blocking initialization
    // Falls back to setTimeout for browsers without support
    if ('requestIdleCallback' in window) {
        requestIdleCallback(() => initThreeJS(), { timeout: 2000 });
    } else {
        setTimeout(initThreeJS, 100);
    }

    </script>
</body>
</html>
